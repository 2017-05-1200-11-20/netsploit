#!/usr/bin/python
# coding=utf-8

'''
 netsploit - a security research tool with shodan implementation
 Copyright (C) 2017 Carter Brainerd

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
'''
import sys
sys.path.append("nsp")
sys.path.append("util")
sys.path.append("modules/misc")
sys.path.append("modules/networking")
sys.path.append("modules/shodan")
import importlib
from   nsp.core import *
from   util.ip_regex import *
import modules.shodan as shodan
import modules.networking as net
import modules.misc as misc


###
#
# Here we deal with getting module names
# We get rid of the extension using replace()
#
###
misc_modules = os.listdir("modules/misc")
misc_titles  = []
for i in range(len(misc_modules)):
    misc_titles.append(i.replace(".py", ""))
net_modules = os.listdir("modules/networking")
net_titles  = []
for i in range(len(net_modules)):
    net_titles.append(i.replace(".py", ""))
sho_modules = os.listdir("modules/shodan")
sho_titles  = []
for i in range(len(sho_modules)):
    sho_titles.append(i.replace(".py", ""))


# Checks for tools directory
if not os.path.isdir(os.getcwd() + '/tools'):
    call(['bash', 'setup.sh'])

# Tries to read the api key from a hidden file
# generated from the setup script
try:
    with open('.api_key', 'r') as f:
        firstline = f.readline()
    f.close()
except:
    # Error case in which the keyfile wasn't found
    print "Couldn't locate api key, running setup.sh"
    call(['bash', 'setup.sh'])

key = firstline.strip()
# Since the colors are not defined as variables yet
# we need to use the raw octal code for them
print "\033[96mStarting netsploit...\033[0m"
api = shodan.Shodan(key)
try:
    # Check if API key is valid
    test = api.info()
except:
    print "\033[31mInvalid API key\033[0m"
    sys.exit(0)
call(['clear'])  # clear the screen

# predefined commands
cmds = ['search', 'exit', 'search_host', 'facets', 'help', 'myip', 'exec', 'banner', 'resolve',
'portscan', 'slowloris', 'ssl', 'mailsniff', 'heartbleed', '3d', 'robots', 'honeyscore', 'protocols',
'internet', 'cam', 'blacknurse', 'cfresolve', 'history', 'subbrute', 'tcpstream']  # NOTE: This is going to be replaced

'''
cmds = []
for _ in range(len(misc_titles)):
    cmds.append(misc_modules[_])
for _ in range(len(net_titles)):
    cmds.append(net_modules[_])
for _ in range(len(sho_titles)):
    cmds.append(sho_modules[_])
'''
print banners()


####
#
# These handle the
# command functions
#
####


# Doesn't use shodan, but it works well and it's fast
# the regex here is insane I wanted to kms doing it
def myip():
    f = urllib.urlopen("http://www.canyouseeme.org/")
    html_doc = f.read()
    f.close()
    m = find_ip(html_doc)
    print_good("Your IP is %s" % m.group(0))

# XXX: I'm pretty sure that this doesn't work
def portscan(host, mini, maxi):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    open_ports = 0
    for port in range(mini, maxi):
        result = s.connect_ex((host, port))
        if result == 0:
            print_good("Open port: {}".format(port))
            open_ports += 1
    print_msg("{} has {} open ports.".format(host, open_ports))

def slowloris(tgt, port='80'):
    print_msg("Attacking {} on port {}".format(tgt, port))
    call(['python', 'tools/slowloris/slowloris.py', tgt, '-ua', '-p', port])

# This function uses sslyze.
# sslyze should be in the $PATH when setup.sh is run
def ssl(target, outfile=False, filename=''):
    if not outfile:
        print_msg("Analyzing {}".format(target))
        print_msg("Printing to STDOUT")
        call(['sslyze', '--regular', target])
    else:
        print_msg("Analyzing {}".format(target))
        print_msg("Outputting to {}".format(filename))
        call(['sslyze', '--regular', target, ' > ', filename])

# I could use exec() here to read the .py file instead of running
# another instance of the interpreter, but this works for now
def mailsniff(interface, time):
    try:
        call(['python', 'tools/mail0wner/mail0wner.py', '-q', '-i', interface, '-t', time])
    except KeyboardInterrupt:
        print_err("Stopping sniff...")
        sleep(1)

def hb_test(target, outfile=False, filename=''):
    if not outfile:
        call(['python', 'tools/heartbleed/hb-test.py', target])
    else:
        print_msg("Outputting to {}".format(filename))
        call(['python', 'tools/heartbleed/hb-test.py', '-f', filename, target])



def subbrute(host, outfile=False, filename=''):
    if not outfile:
        print_msg("Enumerating {} subdomains".format(host))
        call(['python', 'tools/Sublist3r/sublist3r.py', '-d', host, '-v'])
    else:
        print_msg("Enumerating {} subdomains (Outputting results to text file)".format(host))
        call(['python', 'tools/Sublist3r/sublist3r.py', '-d', host, '-v', '-o', filename])

# Tcpdump the LAN
def dump(outfile=False, filename=''):
    try:
        if not outfile:
            call(['tcpdump'])
        else:
            call(['tcpdump', '-w', filename])
    except KeyboardInterrupt:
        return

####
#
# This handles the prompt
#
####

def main():
    ban = banner()
    print ban
    history = ""
    ite = 1  # Iterator for the 'history' command
    import readline
    while True:
        try:
            user_in = raw_input(bcolors.UL + "netsploit{} > ".format(bcolors.ENDC))  # prompt
            user_in = user_in.strip()

            # These 3 lines implement the history command.
            # It first checks if the input is blank,
            # Then appends the command number and used command
            # To the 'history' string
            if not user_in == '':
                history += str(ite) + "  " + user_in + "\n"
                ite += 1

            # BUG: input validation needs to be fixed. right now
            # if "search" and "facets" are in the same input
            # line, it doesnt know what to do. It's assuming
            # the standard input, but bugs WILL occur if it's
            # not formatted correctly

            if cmds["search"] in user_in and not "_host" in user_in:  # search
                inarr = user_in.split(' ')
                if len(inarr) == 1:
                    print shodan.search.help()
                elif len(inarr) == 2:
                    shodan.search.search(api, inarr[1])
                elif len(inarr) == 3:
                    shodan.search.search(api, inarr[1], True, inarr[2])

            elif user_in == cmds["exit"]:  # exit
                print_err("Exiting.")
                sys.exit(0)

            elif cmds["search_host"] in user_in:  # search_host
                inarr = user_in.split(' ')
                if len(inarr) == 1:
                    print_msg("\'search_host\' usage: search_host <hostname> [outfilename]")
                elif len(inarr) == 2:
                    search_host(inarr[1])
                elif len(inarr) == 3:
                    search_host(inarr[1], True, inarr[2])

            elif cmds["facets"] in user_in: # facets
                inarr = user_in.split(' ')
                if len(inarr) == 1:
                    print_msg("\'facets\' usage: facets <search query>")
                else:
                    facet_search(inarr[1:])

            elif user_in == cmds[4] or user_in == "?": # help
                print """
Shodan commands:

  Command         Meaning
 ---------       ---------
                """
                #for i in range(len(sho_modules)):
                    # TODO figure out how to format this properly
                print """
Networking commands:

  Command         Meaning
 ---------       ---------
  blacknurse     perform a blacknurse attack on a given ip
  cam            open a random camera in your web browser
  cfresolve      attempt to resolve a domain protected by couldflare
  heartbleed     determine if a server is vulnerable to heartbleed
  internet       scan the whole internet on a given port (noisy)
  myip           get your external IP
  mailsniff      sniff the local network for email credentials
  resolve        resolve the ip of a given hostname
  slowloris      perform a slowloris attack on a target(IP)
  ssl            do a scan of the targets SSL configuration
  subbrute       use Sublist3r to enumerate dubsomeins of a given domain
  tcpstream      output the tcp stream of the network


Misc commands:

  Command         Meaning
 ---------       ---------
  banner         print a starting banner
  clear          clear the screen
  exec           execute shell commands
  exit           exit netsploit
  help           print this help message
  history        show all commands used since runtime
  ?              alias for `help`

                """

            elif user_in == '':
                pass
            elif user_in == "clear":
                call(["clear"])
            elif user_in == cmds[5]:
                myip()
            elif cmds[6] in user_in:
                inarr = user_in.split(' ')
                call(inarr[1:])  # This doesn't really need its own function, as it's only used once
            elif user_in == cmds[7]:
                ban = banner()
                print ban
            elif cmds[8] in user_in and not "cfresolve" in user_in:  # When I added cfresolve, it caused some confusion with this commmand
                inarr = user_in.split(' ')
                if len(inarr) < 2:
                    print "\'resolve\' usage: resolve <domain>"
                try:
                    print_good("{} is {}".format(inarr[1], socket.gethostbyname(inarr[1])))
                except Exception:
                    print_err("Could not resolve {}".format(inarr[1]))
            elif cmds[9] in user_in:
                inarr = user_in.split(' ')
                if len(inarr) < 2:
                    print_msg("\'portscan\' usage: portscan <ip> <min port> <max port>")
                else:
                    portscan(inarr[2], inarr[3], inarr[4])
            elif cmds[10] in user_in:
                inarr = user_in.split(' ')
                if len(inarr) < 2 and not len(inarr) > 4:
                    print_msg("\'slowloris\' usage: slowloris <target IP> [port (default: 80)]")
                elif len(inarr) == 3:
                    try:
                        slowloris(inarr[1], inarr[2])
                    except KeyboardInterrupt:
                        continue
                else:
                    try:
                        slowloris(inarr[1])
                    except KeyboardInterrupt:
                        continue
            elif cmds[11] in user_in:
                inarr = user_in.split(' ')
                if len(inarr) < 2:
                    print_msg("\'ssl\' usage: ssl <target> [outfilename]")
                elif len(inarr) == 2:
                    ssl(inarr[1])
                elif len(inarr) == 3:
                    ssl(inarr[1], True, inarr[2])
            elif user_in == "key":  # No function for this, but it's still an cool little command
                print_msg("Your Shodan API key is: {}".format(key))
            elif cmds[12] in user_in:
                inarr = user_in.split(' ')
                if len(inarr) < 2:
                    print_msg("\'mailsniff\' usage: mailsniff <interface> <time>")
                elif len(inarr) == 2:
                    print_err("Not a full command!")
                    print_msg("\'mailsniff\' usage: mailsniff <interface> <time>")
                else:
                    mailsniff(inarr[1], inarr[2])
            elif cmds[13] in user_in:
                inarr = user_in.split(' ')
                if len(inarr) < 2:
                    print_msg("\'heartbleed\' usage: heartbleed <target ip> [memdumpfile]")
                elif len(inarr) == 2:
                    hb_test(inarr[1])
                else:
                    hb_test(inarr[1], True, inarr[2])
            elif user_in == cmds[14]:
                url = "https://simple.shodan.io/"
                call(['open', url])  # Only works if you have a GUI desktop (or $TERM is set idk)
            elif cmds[15] in user_in:  # I was too lazy to fullt remove this, to fake error messages it is then :)
                inarr = user_in.split(' ')
                print_err("Unknown statement: robots")
            elif cmds[16] in user_in:
                inarr = user_in.split(' ')
                if len(inarr) < 2:
                    print_msg("\'honeyscore\' usage: honeyscore <ip>")
                else:
                    honey(inarr[1])
            elif cmds[17] in user_in:
                protocols()
            elif cmds[18] in user_in:
                inarr = user_in.split(' ')
                if len(inarr) < 2:
                    print_msg("\'internet\' usage: internet <port> [outfilename]")
                elif len(inarr) == 2:
                    print_msg("Outputting to STDOUT.")
                    print_msg("[" + bcolors.WARN + "WARNING" + bcolors.ENDC + "]" + "This will produce a lot of data, it is recommended to output to a file.") # fo real
                    sleep(3)  # Wait for the reader to read the warning
                    call(['zmap', '-p', inarr[1]])  # again, a function isn't really needed
                elif len(inarr) == 3:
                    print_msg("Outputting to {}".format(inarr[2]))
                    call(['zmap', '-p', port, '-o', inarr[2]])
            elif user_in == cmds[19]:
                call(['./tools/c4.sh'])
            elif cmds[20] in user_in:
                inarr = user_in.split(' ')
                if len(inarr) < 2:
                    print_msg("\'blacknurse\' usage: blacknurse <ip>")
                else:
                    call(['./tools/blacknurse/blacknurse', inarr[1]])
            elif cmds[21] in user_in:
                inarr = user_in.split(' ')
                if len(inarr) < 2:
                    print_msg("\'cfresolve\' usage: cfresolve <domain>")
                elif len(inarr) == 2:
                    call(['python', 'tools/cf-resolve.py', inarr[1]])
                else:
                    pass
            elif user_in == "history":
                print history
            elif cmds[23] in user_in:
                inarr = user_in.split(' ')
                if len(inarr) < 2:
                    print_msg("\'subbrute\' usage: subbrute <domain> [outfilename]")
                elif len(inarr) == 2:
                    subbrute(inarr[1])
                elif len(inarr) == 3:
                    subbrute(inarr[1], True, inarr[2 ])
            elif cmds[24] in user_in:
                inarr = user_in.split(' ')
                if len(inarr) == 1:
                    print_msg("Outputting to STDOUT")
                    print_msg("[" + bcolors.WARN + "WARNING" + bcolors.ENDC + "]" + "This will produce a lot of data. Outputting to a file is recommended")
                    sleep(3)
                    dump()
                else:
                    print_msg("Outputting to {}".format(inarr[1]))
                    dump(True, inarr[1])

            else:
                print_err("Unknown statement: {}".format(user_in))
        except Exception as e:
            print_err(e)
            pass
        except KeyboardInterrupt:
            print "\n"
            print_msg("Use \"exit\" to exit the program")
            pass



if __name__ == "__main__":
    main()
